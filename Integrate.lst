CCS PCD C Compiler, Version 5.015, 5967               06-Nov-18 09:27

               Filename:   C:\Users\thipawan\Desktop\Embedded\MilestoneIII\MPIDE\Integrate.lst

               ROM used:   1204 bytes (4%)
                           Largest free fragment is 29512
               RAM used:   149 (2%) at main() level
                           161 (2%) worst case
               Stack size: 128

*
0C00:  GOTO    FFE
*
0C24:  GOTO    F50
*
0C50:  GOTO    F1E
*
0C74:  GOTO    F72
*
0C98:  GOTO    F94
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
....................  
.................... #list 
....................  
.................... #include "BL_Support.h" 
.................... /*  
....................  * File:    BL_Support.h 
....................  * Author:  Dr.Santi Nuratch 
....................  *          Embedded Computing and Control Lab., INC-KMUTT 
....................  * Created on 22 September 2016, 13:14 
....................  */ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #use delay (internal = 8 MHz, clock = 32MHz) 
*
0FEE:  CP0     W0
0FF0:  BTSC.B  42.1
0FF2:  BRA     FFC
0FF4:  REPEAT  #3E7B
0FF6:  NOP     
0FF8:  DEC     W0,W0
0FFA:  BRA     NZ,FF4
0FFC:  RETURN  
.................... #PIN_SELECT U1RX = PIN_B12 //PIN_B14 // 
.................... #PIN_SELECT U1TX = PIN_B13 //PIN_B15 // 
.................... #use rs232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12) 
....................  
....................  
.................... #define TIME_PERIOD 2000 
.................... #define tolerance 30 
....................  
.................... #define servoTop   PIN_B8  
.................... #define	servoUnder  PIN_B15 
....................  
.................... #define	lim_SW_X PIN_B14 
.................... #define lim_SW_Y PIN_B4 
.................... #define lim_SW_Z PIN_B5 
....................  
.................... #define motorXI  PIN_B0  
.................... #define motorXII PIN_B1 
.................... #define ena_X    PIN_B2  
.................... //Encoder X is INT0 PIN_B7 
....................  
.................... #define	motorYI  PIN_A2 
.................... #define motorYII PIN_A4 
.................... #define ena_Y    PIN_B9 
.................... #define	encodeY  PIN_B6 
....................  
.................... #define	motorZI  PIN_A0  
.................... #define motorZII PIN_A1  
.................... #define ena_Z    PIN_B10 
.................... #define	encodeZ  PIN_B3 
....................  
....................  
.................... #PIN_SELECT INT1 = encodeY  
.................... #PIN_SELECT INT2 = encodeZ  
.................... #PIN_SELECT OC1 =  ena_X   
.................... #PIN_SELECT OC2 =  ena_Y 
.................... #PIN_SELECT OC3 =  ena_Z 
.................... #PIN_SELECT OC4 =  servoTop 
.................... #PIN_SELECT OC5 =  servoUnder 
....................  
.................... int countX = 0; 
.................... int countY = 0; 
.................... int countZ = 0;  
....................  
.................... char arrayData[4] = {}; 
.................... char arrayDataXI[2] = {}; 
.................... char arrayDataXII[2] = {}; 
.................... char arrayDataYI[2] = {}; 
.................... char arrayDataYII[2] = {}; 
....................  
.................... char SM_id = 1; 
.................... int getPackage = 0; 
....................  
.................... void SM_RxD(int c){ 
*
0DFC:  MOV     W5,[W15++]
0DFE:  MOV     W6,[W15++]
.................... 	if (SM_id <= 2){ 
0E00:  MOV.B   812,W0L
0E02:  SE      W0,W0
0E04:  CP      W0,#2
0E06:  BRA     GT,E18
.................... 		if (c ==  0xFF){ 
0E08:  MOV     820,W4
0E0A:  XOR     #FF,W4
0E0C:  BRA     NZ,E12
.................... 			SM_id++; 
0E0E:  INC.B   0812
.................... 		}else{ 
0E10:  BRA     E16
.................... 			SM_id = 1; 
0E12:  MOV.B   #1,W0L
0E14:  MOV.B   W0L,812
.................... 		} 
.................... 	}else if (SM_id <= 3){ 
0E16:  BRA     F18
0E18:  MOV.B   812,W0L
0E1A:  SE      W0,W0
0E1C:  CP      W0,#3
0E1E:  BRA     GT,E2A
.................... 		if (c == 0x02){ 
0E20:  MOV     820,W4
0E22:  CP      W4,#2
0E24:  BRA     NZ,E28
.................... 			SM_id++; 
0E26:  INC.B   0812
.................... 		} 
.................... 	}else if (SM_id <= 4){ 
0E28:  BRA     F18
0E2A:  MOV.B   812,W0L
0E2C:  SE      W0,W0
0E2E:  CP      W0,#4
0E30:  BRA     GT,E3C
.................... 		if ( c == 0x08){ 
0E32:  MOV     820,W4
0E34:  CP      W4,#8
0E36:  BRA     NZ,E3A
.................... 			SM_id++; 
0E38:  INC.B   0812
.................... 		} 
.................... 	}else if (SM_id > 4 && SM_id <= 6){ 
0E3A:  BRA     F18
0E3C:  MOV.B   812,W0L
0E3E:  SE      W0,W0
0E40:  CP      W0,#4
0E42:  BRA     LE,E5E
0E44:  MOV.B   812,W0L
0E46:  SE      W0,W0
0E48:  CP      W0,#6
0E4A:  BRA     GT,E5E
.................... 		arrayDataXI[SM_id - 5] = c; 
0E4C:  MOV.B   812,W0L
0E4E:  SE      W0,W0
0E50:  SUB     W0,#5,W5
0E52:  MOV     #80A,W4
0E54:  ADD     W5,W4,W6
0E56:  MOV     820,W0
0E58:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E5A:  INC.B   0812
....................  
.................... 	}else if (SM_id > 6 && SM_id <= 8){ 
0E5C:  BRA     F18
0E5E:  MOV.B   812,W0L
0E60:  SE      W0,W0
0E62:  CP      W0,#6
0E64:  BRA     LE,E80
0E66:  MOV.B   812,W0L
0E68:  SE      W0,W0
0E6A:  CP      W0,#8
0E6C:  BRA     GT,E80
.................... 		arrayDataYI[SM_id - 7] = c; 
0E6E:  MOV.B   812,W0L
0E70:  SE      W0,W0
0E72:  SUB     W0,#7,W5
0E74:  MOV     #80E,W4
0E76:  ADD     W5,W4,W6
0E78:  MOV     820,W0
0E7A:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E7C:  INC.B   0812
....................  
.................... 	}else if (SM_id > 8 && SM_id <= 10){ 
0E7E:  BRA     F18
0E80:  MOV.B   812,W0L
0E82:  SE      W0,W0
0E84:  CP      W0,#8
0E86:  BRA     LE,EA2
0E88:  MOV.B   812,W0L
0E8A:  SE      W0,W0
0E8C:  CP      W0,#A
0E8E:  BRA     GT,EA2
.................... 		arrayData[SM_id - 9] = c; 
0E90:  MOV.B   812,W0L
0E92:  SE      W0,W0
0E94:  SUB     W0,#9,W5
0E96:  MOV     #806,W4
0E98:  ADD     W5,W4,W6
0E9A:  MOV     820,W0
0E9C:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E9E:  INC.B   0812
....................  
.................... 	}else if (SM_id > 10 && SM_id <= 12){ 
0EA0:  BRA     F18
0EA2:  MOV.B   812,W0L
0EA4:  SE      W0,W0
0EA6:  CP      W0,#A
0EA8:  BRA     LE,EC4
0EAA:  MOV.B   812,W0L
0EAC:  SE      W0,W0
0EAE:  CP      W0,#C
0EB0:  BRA     GT,EC4
.................... 		arrayDataXII[SM_id - 11] = c; 
0EB2:  MOV.B   812,W0L
0EB4:  SE      W0,W0
0EB6:  SUB     W0,#B,W5
0EB8:  MOV     #80C,W4
0EBA:  ADD     W5,W4,W6
0EBC:  MOV     820,W0
0EBE:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0EC0:  INC.B   0812
....................  
.................... 	}else if (SM_id > 12 && SM_id <= 14){ 
0EC2:  BRA     F18
0EC4:  MOV.B   812,W0L
0EC6:  SE      W0,W0
0EC8:  CP      W0,#C
0ECA:  BRA     LE,EE6
0ECC:  MOV.B   812,W0L
0ECE:  SE      W0,W0
0ED0:  CP      W0,#E
0ED2:  BRA     GT,EE6
.................... 		arrayDataYII[SM_id - 13] = c; 
0ED4:  MOV.B   812,W0L
0ED6:  SE      W0,W0
0ED8:  SUB     W0,#D,W5
0EDA:  MOV     #810,W4
0EDC:  ADD     W5,W4,W6
0EDE:  MOV     820,W0
0EE0:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0EE2:  INC.B   0812
....................  
.................... 	}else if(SM_id > 14 && SM_id <= 16){ 
0EE4:  BRA     F18
0EE6:  MOV.B   812,W0L
0EE8:  SE      W0,W0
0EEA:  CP      W0,#E
0EEC:  BRA     LE,F08
0EEE:  MOV.B   812,W0L
0EF0:  SE      W0,W0
0EF2:  CP      W0,#10
0EF4:  BRA     GT,F08
.................... 		arrayData[SM_id - 13] = c; 
0EF6:  MOV.B   812,W0L
0EF8:  SE      W0,W0
0EFA:  SUB     W0,#D,W5
0EFC:  MOV     #806,W4
0EFE:  ADD     W5,W4,W6
0F00:  MOV     820,W0
0F02:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0F04:  INC.B   0812
....................  
.................... 	}else if(SM_id > 16){ 
0F06:  BRA     F18
0F08:  MOV.B   812,W0L
0F0A:  SE      W0,W0
0F0C:  CP      W0,#10
0F0E:  BRA     LE,F18
.................... 		getPackage = 1; 
0F10:  MOV     #1,W4
0F12:  MOV     W4,814
.................... 		SM_id = 1; 
0F14:  MOV.B   #1,W0L
0F16:  MOV.B   W0L,812
.................... 	} 
0F18:  MOV     [--W15],W6
0F1A:  MOV     [--W15],W5
0F1C:  RETURN  
.................... } 
....................  
....................  
.................... #INT_RDA               // receive data interrupt one time per one  
.................... void UART1_Isr() { 
0F1E:  PUSH    42
0F20:  PUSH    36
0F22:  PUSH    32
0F24:  MOV     W0,[W15++]
0F26:  MOV     #2,W0
0F28:  REPEAT  #C
0F2A:  MOV     [W0++],[W15++]
0F2C:  BTSS.B  222.0
0F2E:  BRA     F2C
0F30:  MOV     226,W0
0F32:  MOV.B   W0L,81C
0F34:  CLR.B   81D
....................     int c = getc(); 
....................     SM_RxD(c); 
0F36:  PUSH    81C
0F38:  POP     820
0F3A:  CALL    DFC
0F3E:  BCLR.B  85.3
0F40:  MOV     #1A,W0
0F42:  REPEAT  #C
0F44:  MOV     [--W15],[W0--]
0F46:  MOV     [--W15],W0
0F48:  POP     32
0F4A:  POP     36
0F4C:  POP     42
0F4E:  RETFIE  
.................... } 
....................  
.................... void control_inputX(int input, int direc){ 
.................... 	if(direc == 0){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(1, 2000); 
.................... 			output_bit(motorXI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorXII,0); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(1, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorXI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorXII,0); 
.................... 		}else{ 
.................... 			set_pwm_duty(1, 0); 
.................... 			output_bit(motorXI,0); 
.................... 			output_bit(motorXII,0); 
.................... 			} 
.................... 	}	 
.................... 	else if(direc == 1){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(1, 2000); 
.................... 			output_bit(motorXI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorXII,1); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(1, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorXI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorXII,1); 
.................... 		}else{ 
.................... 			set_pwm_duty(1, 0); 
.................... 			output_bit(motorXI,0); 
.................... 			output_bit(motorXII,0); 
.................... 		} 
.................... 	}		 
.................... } 
....................  
....................  
.................... void control_inputY(int input, int direc){ 
.................... 	 
.................... if(direc == 0){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(2, 2000); 
.................... 			output_bit(motorYI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorYII,0); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(2, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorYI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorYII,0); 
.................... 		}else{ 
.................... 			set_pwm_duty(2, 0); 
.................... 			output_bit(motorYI,0); 
.................... 			output_bit(motorYII,0); 
.................... 			} 
.................... 	}	 
.................... 	else if(direc == 1){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(2, 2000); 
.................... 			output_bit(motorYI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorYII,1); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(2, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorYI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorYII,1); 
.................... 		}else{ 
.................... 			set_pwm_duty(2, 0); 
.................... 			output_bit(motorYI,0); 
.................... 			output_bit(motorYII,0); 
.................... 			 
.................... 		}		 
.................... 	} 
.................... } 
....................  
.................... void control_inputZ(int input, int direc){ 
.................... 	if(direc == 0){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(3, 2000); 
.................... 			output_bit(motorZI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorZII,0); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(3, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorZI,1); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorZII,0); 
.................... 		}else{ 
.................... 			set_pwm_duty(3, 0);				 
.................... 			output_bit(motorZI,0); 
.................... 			output_bit(motorZII,0); 
.................... 				} 
.................... 	}	 
.................... 	else if(direc == 1){ 
.................... 		if(input >= 743 ){ 
.................... 			set_pwm_duty(3, 2000); 
.................... 			output_bit(motorZI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorZII,1); 
.................... 		}else if(input > 0 ){ 
.................... 			set_pwm_duty(3, (int)((input/743.0f)*2000)); 
.................... 			output_bit(motorZI,0); //if 0, IN2->AXI@2 = clockwise  
.................... 			output_bit(motorZII,1); 
.................... 		}else{ 
.................... 			set_pwm_duty(3, 0); 
.................... 			output_bit(motorZI,0); 
.................... 			output_bit(motorZII,0); 
.................... 				 
.................... 			}		 
.................... 		} 
.................... 	} 
....................  
.................... void move_posX(int pulse_x, int direc){ 
.................... 	int check = 1; 
.................... 	while(check == 1){   
.................... 		int error = pulse_x - countX; 
.................... 			error *= 2; 
.................... 		//printf("error:%d\n",error); 
.................... 		//delay_ms(10); 
....................  
.................... 		if(abs(error) <= tolerance){ 
.................... 			control_inputX(0,direc); 
.................... 			check = 0;	 
.................... 		}else{ 
.................... 			control_inputX(error, direc);  
.................... 			 
.................... 			 
.................... 		} 
.................... 	} 
.................... } 
....................  
.................... void move_posY(int pulse_y, int direc){ 
.................... 	int check = 1; 
.................... 	while(check == 1){ 
.................... 		int error = pulse_y - countY; 
.................... 		if(abs(error) <= tolerance){ 
.................... 			control_inputY(0, direc); 
.................... 			check = 0;	 
.................... 		}else{ 
.................... 			control_inputY(error, direc);  
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
.................... void move_posZ(int pulse_z, int direc){ 
.................... 	int check = 1; 
.................... 	while(check == 1){ 
.................... 	int error = pulse_z - countZ; 
.................... 		if(abs(error) <= tolerance){ 
.................... 			control_inputZ(0, direc);	 
.................... 			check = 0; 
.................... 		}else{ 
.................... 			control_inputZ(error, direc); 
.................... 		}  
.................... 	} 
.................... } 
....................  
....................  
.................... void set_Z(void){ 
.................... 	int check = 1; 
.................... 	while(check == 1){  
.................... 		if(input(lim_SW_Z) == 1){ 
.................... 			control_inputZ(0, 0); 
.................... 			check = 0; 
.................... 		}else if(input(lim_SW_Z) == 0){ 
.................... 			control_inputZ(700, 0); 
.................... 		} 
.................... 	} 
.................... } 
....................  
....................  
.................... void set_Zero(void){ 
.................... 	int loop = 1; 
.................... 	int stateSWII = 0; 
.................... 	while(loop == 1){ 
.................... 		if(stateSWII == 0){ 
.................... 			set_Z(); 
.................... 			stateSWII++; 
.................... 		}else if(stateSWII == 1){   
.................... 			if(input(lim_SW_Y) == 1){ 
.................... 				control_inputY(0,1); 
.................... 				stateSWII++; 
.................... 			}else if(input(lim_SW_Y) == 0){ 
.................... 				control_inputY(700,0); 
.................... 			} 
.................... 		}else if(stateSWII == 2){   
.................... 			if(input(lim_SW_X) == 1){ 
.................... 				control_inputX(0,0); 
.................... 				loop=0; 
.................... 			}else if(input(lim_SW_X) == 0){ 
.................... 				control_inputX(700,0); 
.................... 			} 
.................... 		} 
.................... 	}  
.................... } 
....................  
.................... void moveXYZ(int x, int direcX, int y, int direcY, int z, int direcZ){ 
....................  
.................... int loop = 1; 
.................... int stateSWIII = 0; 
.................... 	while(loop == 1){ 
.................... 		if(stateSWIII == 0){ 
.................... 			move_posX(x, direcX); 
.................... 			stateSWIII = 1; 
.................... 		}else if(stateSWIII == 1){   
.................... 			move_posY(y, direcY); 
.................... 			stateSWIII = 2; 
.................... 		}else if(stateSWIII == 2){   
.................... 			move_posZ(z, direcZ); 
.................... 			stateSWIII = 0; 
.................... 			loop = 0; 
.................... 		} 
.................... 	}  
.................... } 
....................  
.................... void control_ServoTop(int input, int direc){ 
.................... 	if(direc == 1){ 
.................... 		set_pwm_duty(4, (int)((input/90.0f)*5000)); 
.................... 	}else if(direc == 0){ 
.................... 		set_pwm_duty(4, (int)(90.0f - ((input/90.0f)*5000))); 
.................... 		} 
.................... 	}	 
....................  
.................... #INT_EXT0 
.................... void INT_EXT_INPUT0 (void) 
0F50:  PUSH    42
0F52:  PUSH    36
0F54:  PUSH    32
0F56:  MOV     W0,[W15++]
0F58:  MOV     #2,W0
0F5A:  REPEAT  #C
0F5C:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countX++; 
0F5E:  INC     0800
.................... } 
0F60:  BCLR.B  84.0
0F62:  MOV     #1A,W0
0F64:  REPEAT  #C
0F66:  MOV     [--W15],[W0--]
0F68:  MOV     [--W15],W0
0F6A:  POP     32
0F6C:  POP     36
0F6E:  POP     42
0F70:  RETFIE  
.................... #INT_EXT1 
.................... void INT_EXT_INPUT1 (void) 
0F72:  PUSH    42
0F74:  PUSH    36
0F76:  PUSH    32
0F78:  MOV     W0,[W15++]
0F7A:  MOV     #2,W0
0F7C:  REPEAT  #C
0F7E:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countY++; 
0F80:  INC     0802
.................... } 
0F82:  BCLR.B  86.4
0F84:  MOV     #1A,W0
0F86:  REPEAT  #C
0F88:  MOV     [--W15],[W0--]
0F8A:  MOV     [--W15],W0
0F8C:  POP     32
0F8E:  POP     36
0F90:  POP     42
0F92:  RETFIE  
.................... #INT_EXT2 
.................... void INT_EXT_INPUT2 (void) 
0F94:  PUSH    42
0F96:  PUSH    36
0F98:  PUSH    32
0F9A:  MOV     W0,[W15++]
0F9C:  MOV     #2,W0
0F9E:  REPEAT  #C
0FA0:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countZ++; 
0FA2:  INC     0804
0FA4:  BCLR.B  87.5
0FA6:  MOV     #1A,W0
0FA8:  REPEAT  #C
0FAA:  MOV     [--W15],[W0--]
0FAC:  MOV     [--W15],W0
0FAE:  POP     32
0FB0:  POP     36
0FB2:  POP     42
0FB4:  RETFIE  
.................... } 
.................... void Init_Interrupts() 
.................... { 
.................... 	disable_interrupts(GLOBAL); 
0FB6:  BCLR.B  81.7
0FB8:  MOV     #E0,W4
0FBA:  MOV     W4,42
0FBC:  BSET.B  81.7
.................... 	 
.................... 	clear_interrupt(INT_RDA);   // recommend style coding to confirm everything clear before use 
0FBE:  REPEAT  #3
0FC0:  MOV     226,W0
0FC2:  BCLR.B  85.3
....................     enable_interrupts(INT_RDA); 
0FC4:  BSET.B  95.3
....................  
.................... 	enable_interrupts( INT_EXT0 ); 
0FC6:  BSET.B  94.0
.................... 	ext_int_edge( 0, L_TO_H ) ; 
0FC8:  BCLR.B  82.0
....................  
.................... 	enable_interrupts( INT_EXT1 ); 
0FCA:  BSET.B  96.4
.................... 	ext_int_edge( 1, L_TO_H ) ; 
0FCC:  BCLR.B  82.1
....................  
.................... 	enable_interrupts( INT_EXT2 ); 
0FCE:  BSET.B  97.5
.................... 	ext_int_edge( 2, L_TO_H ) ; 
0FD0:  BCLR.B  82.2
.................... 	 
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_64 ,5000); 
0FD2:  CLR     110
0FD4:  MOV     #1388,W4
0FD6:  MOV     W4,10C
0FD8:  MOV     #8020,W4
0FDA:  MOV     W4,110
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_8 ,TIME_PERIOD); 
0FDC:  CLR     112
0FDE:  MOV     #7D0,W4
0FE0:  MOV     W4,10E
0FE2:  MOV     #8010,W4
0FE4:  MOV     W4,112
....................  
....................  
.................... 	enable_interrupts(GLOBAL); 
0FE6:  BCLR.B  81.7
0FE8:  CLR     42
0FEA:  BSET.B  81.7
0FEC:  RETURN  
....................  
.................... } 
....................  
.................... void main(){ 
*
0FFE:  MOV     #2780,W15
1000:  MOV     #27FF,W0
1002:  MOV     W0,20
1004:  NOP     
1006:  MOV     #4444,W0
1008:  MOV     W0,A8
100A:  BSET.B  81.7
100C:  MOV     #46,W0
100E:  MOV.B   W0L,742
1010:  MOV     #57,W0
1012:  MOV.B   W0L,742
1014:  BCLR.B  742.6
1016:  MOV     #63F,W0
1018:  MOV     W0,680
101A:  MOV     #3F03,W0
101C:  MOV     W0,682
101E:  MOV     #3F0C,W0
1020:  MOV     W0,6A4
1022:  MOV     #12,W0
1024:  MOV     W0,6C2
1026:  MOV     #1315,W0
1028:  MOV     W0,6C8
102A:  MOV     #14,W0
102C:  MOV     W0,6CA
102E:  MOV     #300,W0
1030:  MOV     W0,6CC
1032:  MOV     #1600,W0
1034:  MOV     W0,6CE
1036:  MOV     #46,W0
1038:  MOV.B   W0L,742
103A:  MOV     #57,W0
103C:  MOV.B   W0L,742
103E:  BSET.B  742.6
1040:  CLR     744
1042:  MOV     #8000,W4
1044:  MOV     W4,220
1046:  MOV     #400,W4
1048:  MOV     W4,222
104A:  BSET.B  220.3
104C:  MOV     #22,W4
104E:  MOV     W4,228
1050:  CLR     800
1052:  CLR     802
1054:  CLR     804
1056:  MOV.B   #1,W0L
1058:  MOV.B   W0L,812
105A:  CLR     814
105C:  SETM    32C
105E:  CLR     806
1060:  CLR     808
1062:  CLR     80A
1064:  CLR     80C
1066:  CLR     80E
1068:  CLR     810
.................... 	Init_Interrupts(); 
106A:  CALL    FB6
....................  
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 
106E:  MOV     #E,W4
1070:  MOV     W4,184
.................... 	setup_compare(2, COMPARE_PWM | COMPARE_TIMER3); 
1072:  MOV     #E,W4
1074:  MOV     W4,18A
.................... 	setup_compare(3, COMPARE_PWM | COMPARE_TIMER3); 
1076:  MOV     #E,W4
1078:  MOV     W4,190
....................  
.................... 	setup_compare(4, COMPARE_PWM | COMPARE_TIMER2); 
107A:  MOV     #6,W4
107C:  MOV     W4,196
.................... 	setup_compare(5, COMPARE_PWM | COMPARE_TIMER2); 
107E:  MOV     #6,W4
1080:  MOV     W4,19C
.................... 	int stateI = 0; 
1082:  CLR     816
.................... 	while(TRUE){ 
.................... 			//set_pwm_duty(5, 90);//for 5,up is 250,down is 110 
.................... 			for(int i=700;i>40;i-=10){ 
1084:  MOV     #2BC,W4
1086:  MOV     W4,818
1088:  MOV     818,W4
108A:  MOV     #28,W3
108C:  CP      W3,W4
108E:  BRA     GE,10A2
.................... 			set_pwm_duty(4, i);//for 4,up is 650,down is 50 
1090:  PUSH    818
1092:  POP     192
.................... 			//printf("i: %d\n",i); 
.................... 			delay_ms(100); 
1094:  MOV     #64,W0
1096:  CALL    FEE
109A:  MOV     818,W4
109C:  SUB     W4,#A,W0
109E:  MOV     W0,818
10A0:  BRA     1088
.................... 			} 
.................... 			//delay_ms(20); 
....................  
....................  
.................... 		//for(int i=0; i < 200;i+=10){ 
.................... 		//	set_pwm_duty(4, i); 
.................... 			//printf("j: %d\n",j); 
.................... 		//	delay_ms(1000); 
.................... 		//set_Zero(); 
.................... 		//set_Z(2000); 
.................... 		//move_posZ(3000,1); 
.................... 		//move_posY(3000,1); 
.................... 		//int bagPosX, bagPosY, goPosX, goPosY ; 
.................... 		if (getPackage >= 1){ 
10A2:  MOV     814,W4
10A4:  CP      W4,#1
10A6:  BRA     LT,10B0
.................... 			getPackage = 0; 
10A8:  CLR     814
.................... 			if(stateI ==0){ 
10AA:  CP0     816
10AC:  BRA     NZ,10B0
.................... 			//moveXYZ(3000, 1, 3000, 1, 2500, 0); 
.................... 			//set_Zero(); 
.................... 			//control_ServoTop(10, 1); 
.................... 			stateI++; 
10AE:  INC     0816
.................... 			} 
.................... 			//move_posX(3000,1); 
.................... 			//moveXYZ(1000, 1, 1000, 1, 1000, 1); 
.................... 			//set_Zero(); 
.................... 			//moveXYZ(3000, 1, 3000, 1, 1000, 1);	22 
.................... 			//memcpy(&bagPosX, arrayDataXI, sizeof(bagPosX)); 
.................... 			//memcpy(&bagPosY, arrayDataYI, sizeof(bagPosY)); 
.................... 			//memcpy(&goPosX, arrayDataXII, sizeof(goPosX)); 
.................... 			//memcpy(&goPosY, arrayDataYII, sizeof(goPosY)); 
.................... 			//printf("\nresult = %d\n", array[0]); 
.................... 			//printf("\nresult = %d\n", bagPosX); 
.................... 			//printf("\nresult = %d\n", arrayData[0]); 
.................... 			//printf("\nresult = %d\n", arrayData[1]); 
.................... 			//printf("\nresult = %d\n", arrayData[2]); 
.................... 			//printf("\nresult = %d\n", arrayData[3]); 
.................... 		}	 
10B0:  BRA     1084
.................... 	} 
.................... } 
....................  
10B2:  PWRSAV  #0
....................  

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
