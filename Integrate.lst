CCS PCD C Compiler, Version 5.015, 5967               13-Nov-18 20:06

               Filename:   C:\Users\thipawan\Desktop\Embedded\MilestoneIII\MPIDE\Integrate.lst

               ROM used:   3472 bytes (10%)
                           Largest free fragment is 27244
               RAM used:   151 (2%) at main() level
                           255 (3%) worst case
               Stack size: 128

*
0C00:  GOTO    1822
*
0C24:  GOTO    F84
*
0C50:  GOTO    F52
*
0C74:  GOTO    FA6
*
0C98:  GOTO    FC8
.................... #include <24FJ48GA002.h> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
1022:  MOV     W5,[W15++]
1024:  MOV     #C,W5
1026:  REPEAT  #3
1028:  MOV     [W5++],[W15++]
102A:  MOV     W0,W4
102C:  MOV     W1,W5
102E:  MOV     W2,W6
1030:  MOV     W3,W7
1032:  CLR     W0
1034:  CLR     W1
1036:  CLR     W2
1038:  CLR     W3
103A:  BCLR    W8.0
103C:  BTSS    W7.F
103E:  BRA     104A
1040:  BSET    W8.0
1042:  NEG     W4,W4
1044:  COM     W5,W5
1046:  COM     W6,W6
1048:  COM     W7,W7
104A:  IOR      W4,  W5,W9
104C:  BRA     NZ,1052
104E:  IOR      W6,  W7,W9
1050:  BRA     Z,107C
1052:  MOV     #473,W9
1054:  BTSC    W3.4
1056:  BRA     106E
1058:  BCLR.B  42.0
105A:  RLC     W4,W4
105C:  RLC     W5,W5
105E:  RLC     W6,W6
1060:  RLC     W7,W7
1062:  RLC     W0,W0
1064:  RLC     W1,W1
1066:  RLC     W2,W2
1068:  RLC     W3,W3
106A:  DEC     W9,W9
106C:  BRA     NZ,1054
106E:  SL      W9,#4,W9
1070:  BCLR.B  42.0
1072:  BCLR    W9.F
1074:  BCLR    W3.4
1076:  XOR     W9,W3,W3
1078:  BTSC    W8.0
107A:  BSET    W3.F
107C:  MOV     #12,W5
107E:  REPEAT  #3
1080:  MOV     [--W15],[W5--]
1082:  MOV     [--W15],W5
1084:  RETURN  
1086:  MOV     W8,[W15++]
1088:  MOV     #12,W8
108A:  REPEAT  #4
108C:  MOV     [W8++],[W15++]
108E:  XOR     W3,W7,W13
1090:  MOV     W3,W8
1092:  MOV     W7,W9
1094:  MOV     #7FF,W10
1096:  BCLR.B  42.0
1098:  BCLR.B  42.1
109A:  ASR     W8,#4,W8
109C:  AND     W10,W8,W8
109E:  CP0     W8
10A0:  BRA     Z,117A
10A2:  BCLR.B  42.0
10A4:  BCLR.B  42.1
10A6:  ASR     W9,#4,W9
10A8:  AND     W10,W9,W9
10AA:  CP0     W9
10AC:  BRA     Z,117A
10AE:  CLR     W10
10B0:  SUB     W8,W9,W12
10B2:  BRA     NC,10BA
10B4:  ADD     #3FF,W12
10B6:  BRA     C,117A
10B8:  BRA     10C2
10BA:  MOV     #401,W11
10BC:  SUB     W12,W11,W12
10BE:  BRA     NC,117A
10C0:  BRA     Z,117A
10C2:  CLR     W8
10C4:  CLR     W9
10C6:  CLR     W10
10C8:  CLR     W11
10CA:  AND     #1F,W3
10CC:  BSET    W3.4
10CE:  AND     #1F,W7
10D0:  BSET    W7.4
10D2:  MOV     W12,[W15++]
10D4:  MOV     #36,W12
10D6:  SUB     W0,W4,W0
10D8:  SUBB    W1,W5,W1
10DA:  SUBB    W2,W6,W2
10DC:  SUBB    W3,W7,W3
10DE:  BRA     N,10E4
10E0:  BRA     C,10EE
10E2:  BRA     NZ,10F0
10E4:  ADD     W0,W4,W0
10E6:  ADDC    W1,W5,W1
10E8:  ADDC    W2,W6,W2
10EA:  ADDC    W3,W7,W3
10EC:  BRA     10F0
10EE:  BSET    W8.0
10F0:  DEC     W12,W12
10F2:  BRA     Z,110A
10F4:  BCLR.B  42.0
10F6:  RLC     W0,W0
10F8:  RLC     W1,W1
10FA:  RLC     W2,W2
10FC:  RLC     W3,W3
10FE:  BCLR.B  42.0
1100:  RLC     W8,W8
1102:  RLC     W9,W9
1104:  RLC     W10,W10
1106:  RLC     W11,W11
1108:  BRA     10D6
110A:  MOV     [--W15],W12
110C:  BTSC    W11.5
110E:  BRA     1112
1110:  BRA     111E
1112:  BCLR.B  42.0
1114:  RRC     W11,W11
1116:  RRC     W10,W10
1118:  RRC     W9,W9
111A:  RRC     W8,W8
111C:  BRA     1124
111E:  DEC     W12,W12
1120:  BCLR.B  42.0
1122:  BRA     Z,117A
1124:  BTSC.B  42.0
1126:  BRA     113A
1128:  RLC     W0,W0
112A:  RLC     W1,W1
112C:  RLC     W2,W2
112E:  RLC     W3,W3
1130:  SUB     W0,W4,W4
1132:  SUBB    W1,W5,W5
1134:  SUBB    W2,W6,W6
1136:  SUBB    W3,W7,W7
1138:  BRA     NC,1164
113A:  INC     W8,W8
113C:  BRA     NZ,1164
113E:  INC     W9,W9
1140:  BRA     NZ,1164
1142:  INC     W10,W10
1144:  BRA     NZ,1164
1146:  INC     W11,W11
1148:  BRA     NZ,1164
114A:  INC     W12,W12
114C:  BRA     Z,117A
114E:  BRA     1164
1150:  DEC     W12,W12
1152:  BRA     Z,117A
1154:  BTSC    W11.4
1156:  BRA     1164
1158:  BCLR.B  42.0
115A:  RLC     W8,W8
115C:  RLC     W9,W9
115E:  RLC     W10,W10
1160:  RLC     W11,W11
1162:  BRA     1154
1164:  SL      W12,#4,W12
1166:  BCLR.B  42.0
1168:  BCLR    W12.F
116A:  BTSC    W13.F
116C:  BSET    W12.F
116E:  BCLR    W11.4
1170:  XOR     W12,W11,W3
1172:  MOV     W10,W2
1174:  MOV     W9,W1
1176:  MOV     W8,W0
1178:  BRA     1184
117A:  MOV     #0,W0
117C:  MOV     #0,W1
117E:  MOV     #0,W2
1180:  MOV     #0,W3
1182:  BRA     1184
1184:  MOV     #1A,W8
1186:  REPEAT  #4
1188:  MOV     [--W15],[W8--]
118A:  MOV     [--W15],W8
118C:  RETURN  
118E:  MOV     W8,[W15++]
1190:  MOV     #12,W8
1192:  REPEAT  #4
1194:  MOV     [W8++],[W15++]
1196:  CLR     W11
1198:  MUL.UU  W12,#0,W12
119A:  MOV     W3,W8
119C:  MOV     W7,W9
119E:  MOV     #7FF,W10
11A0:  BCLR.B  42.0
11A2:  BCLR.B  42.1
11A4:  ASR     W8,#4,W8
11A6:  AND     W10,W8,W8
11A8:  CP0     W8
11AA:  BRA     Z,128E
11AC:  BCLR.B  42.0
11AE:  BCLR.B  42.1
11B0:  ASR     W9,#4,W9
11B2:  AND     W10,W9,W9
11B4:  CP0     W9
11B6:  BRA     Z,128E
11B8:  ADD     W9,W8,W8
11BA:  BTSC    W9.B
11BC:  BRA     11C6
11BE:  SUB     #3FF,W8
11C0:  BRA     Z,128E
11C2:  BRA     NC,128E
11C4:  BRA     11CC
11C6:  MOV     #401,W10
11C8:  ADD.B   W10L,W5L,W5L
11CA:  BRA     C,128E
11CC:  XOR     W3,W7,W13
11CE:  BCLR.B  42.0
11D0:  BCLR.B  42.1
11D2:  AND     #F,W3
11D4:  BSET    W3.4
11D6:  AND     #F,W7
11D8:  BSET    W7.4
11DA:  MOV     W8,[W15++]
11DC:  MUL.UU  W4,W1,W8
11DE:  MUL.UU  W5,W0,W10
11E0:  ADD     W8,W10,W10
11E2:  ADDC    W9,W11,W11
11E4:  ADDC    #0,W12
11E6:  MUL.UU  W4,W2,W8
11E8:  ADD     W8,W11,W11
11EA:  ADDC    W9,W12,W12
11EC:  MUL.UU  W5,W1,W8
11EE:  CLR     W10
11F0:  ADD     W8,W11,W11
11F2:  ADDC    W9,W12,W12
11F4:  ADDC    #0,W10
11F6:  MUL.UU  W6,W0,W8
11F8:  ADD     W8,W11,W11
11FA:  ADDC    W9,W12,W12
11FC:  ADDC    #0,W10
11FE:  CLR     W11
1200:  MUL.UU  W4,W3,W8
1202:  ADD     W8,W12,W12
1204:  ADDC    W9,W10,W10
1206:  ADDC    #0,W11
1208:  MUL.UU  W5,W2,W8
120A:  ADD     W8,W12,W12
120C:  ADDC    W9,W10,W10
120E:  ADDC    #0,W11
1210:  MUL.UU  W6,W1,W8
1212:  ADD     W8,W12,W12
1214:  ADDC    W9,W10,W10
1216:  ADDC    #0,W11
1218:  MUL.UU  W7,W0,W8
121A:  ADD     W8,W12,W12
121C:  ADDC    W9,W10,W10
121E:  ADDC    #0,W11
1220:  MOV     W12,W0
1222:  CLR     W12
1224:  MUL.UU  W5,W3,W8
1226:  ADD     W8,W10,W10
1228:  ADDC    W9,W11,W11
122A:  ADDC    #0,W12
122C:  MUL.UU  W6,W2,W8
122E:  ADD     W8,W10,W10
1230:  ADDC    W9,W11,W11
1232:  ADDC    #0,W12
1234:  MUL.UU  W6,W3,W8
1236:  ADD     W8,W11,W11
1238:  ADDC    W9,W12,W12
123A:  MUL.UU  W7,W1,W8
123C:  ADD     W8,W10,W10
123E:  ADDC    W9,W11,W11
1240:  ADDC    #0,W12
1242:  MUL.UU  W7,W2,W8
1244:  ADD     W8,W11,W11
1246:  ADDC    W9,W12,W12
1248:  MUL.UU  W7,W3,W8
124A:  ADD     W8,W12,W12
124C:  MOV     W10,W1
124E:  MOV     W11,W2
1250:  MOV     W12,W3
1252:  MOV     #5,W4
1254:  BCLR.B  42.0
1256:  RRC     W3,W3
1258:  RRC     W2,W2
125A:  RRC     W1,W1
125C:  RRC     W0,W0
125E:  DEC     W4,W4
1260:  BRA     NZ,1254
1262:  MOV     [--W15],W8
1264:  INC     W8,W8
1266:  IOR      W0,  W1,W6
1268:  BRA     Z,126C
126A:  BRA     1270
126C:  IOR      W2,  W3,W6
126E:  BRA     Z,1280
1270:  BTSC    W3.4
1272:  BRA     1280
1274:  BCLR.B  42.0
1276:  RLC     W0,W0
1278:  RLC     W1,W1
127A:  RLC     W2,W2
127C:  RLC     W3,W3
127E:  DEC     W8,W8
1280:  SL      W8,#4,W8
1282:  BCLR    W3.F
1284:  BTSC    W13.F
1286:  BSET    W3.F
1288:  BCLR    W3.4
128A:  XOR     W8,W3,W3
128C:  BRA     1294
128E:  MUL.UU  W0,#0,W0
1290:  MUL.UU  W0,#0,W2
1292:  BRA     1294
1294:  MOV     #1A,W8
1296:  REPEAT  #4
1298:  MOV     [--W15],[W8--]
129A:  MOV     [--W15],W8
129C:  RETURN  
129E:  MOV     W5,[W15++]
12A0:  MOV     #C,W5
12A2:  REPEAT  #5
12A4:  MOV     [W5++],[W15++]
12A6:  MOV     W3,W8
12A8:  MOV     W2,W7
12AA:  MOV     W1,W6
12AC:  MOV     W0,W5
12AE:  MOV     W3,W9
12B0:  MOV     #473,W11
12B2:  ASR     W3,#4,W3
12B4:  MOV     #7FF,W10
12B6:  AND     W10,W3,W3
12B8:  SUB     W11,W3,W11
12BA:  AND     #1F,W8
12BC:  BSET    W8.4
12BE:  CLR     W0
12C0:  CLR     W1
12C2:  CLR     W2
12C4:  CLR     W3
12C6:  BCLR.B  42.0
12C8:  RRC     W8,W8
12CA:  RRC     W7,W7
12CC:  RRC     W6,W6
12CE:  RRC     W5,W5
12D0:  RRC     W3,W3
12D2:  RRC     W2,W2
12D4:  RRC     W1,W1
12D6:  RRC     W0,W0
12D8:  DEC     W11,W11
12DA:  BRA     NZ,12C6
12DC:  BTSS    W9.F
12DE:  BRA     12EA
12E0:  NEG     W0,W0
12E2:  COM     W1,W1
12E4:  COM     W2,W2
12E6:  COM     W3,W3
12E8:  BRA     12EA
12EA:  MOV     #16,W5
12EC:  REPEAT  #5
12EE:  MOV     [--W15],[W5--]
12F0:  MOV     [--W15],W5
12F2:  RETURN  
....................  
.................... #list 
....................  
.................... #include "BL_Support.h" 
.................... /*  
....................  * File:    BL_Support.h 
....................  * Author:  Dr.Santi Nuratch 
....................  *          Embedded Computing and Control Lab., INC-KMUTT 
....................  * Created on 22 September 2016, 13:14 
....................  */ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #use delay (internal = 8 MHz, clock = 32MHz) 
*
1812:  CP0     W0
1814:  BTSC.B  42.1
1816:  BRA     1820
1818:  REPEAT  #3E7B
181A:  NOP     
181C:  DEC     W0,W0
181E:  BRA     NZ,1818
1820:  RETURN  
.................... #PIN_SELECT U1RX = PIN_B12 //PIN_B14 // 
.................... #PIN_SELECT U1TX = PIN_B13 //PIN_B15 // 
.................... #use rs232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12) 
....................  
....................  
.................... #define TIME_PERIOD 2000 
.................... #define tolerance 30 
....................  
.................... #define servoTop   PIN_B8  
.................... #define	servoUnder  PIN_B15 
....................  
.................... #define	lim_SW_X PIN_B14 
.................... #define lim_SW_Y PIN_B4 
.................... #define lim_SW_Z PIN_B5 
....................  
.................... #define motorXI  PIN_B0  
.................... #define motorXII PIN_B1 
.................... #define ena_X    PIN_B2  
.................... //Encoder X is INT0 PIN_B7 
....................  
.................... #define	motorYI  PIN_A2 
.................... #define motorYII PIN_A4 
.................... #define ena_Y    PIN_B9 
.................... #define	encodeY  PIN_B6 
....................  
.................... #define	motorZI  PIN_A0  
.................... #define motorZII PIN_A1  
.................... #define ena_Z    PIN_B10 
.................... #define	encodeZ  PIN_B3 
....................  
....................  
.................... #PIN_SELECT INT1 = encodeY  
.................... #PIN_SELECT INT2 = encodeZ  
.................... #PIN_SELECT OC1 =  ena_X   
.................... #PIN_SELECT OC2 =  ena_Y 
.................... #PIN_SELECT OC3 =  ena_Z 
.................... #PIN_SELECT OC4 =  servoTop 
.................... #PIN_SELECT OC5 =  servoUnder 
....................  
.................... int countX = 0; 
.................... int countY = 0; 
.................... int countZ = 0;  
....................  
.................... char arrayData[6] = {}; 
.................... char arrayDataXI[2] = {}; 
.................... char arrayDataXII[2] = {}; 
.................... char arrayDataYI[2] = {}; 
.................... char arrayDataYII[2] = {}; 
....................  
.................... char SM_id = 1; 
.................... int getPackage = 0; 
.................... void SM_RxD(int c){ 
*
0DFC:  MOV     W5,[W15++]
0DFE:  MOV     W6,[W15++]
.................... 	if (SM_id <= 2){ 
0E00:  MOV.B   814,W0L
0E02:  SE      W0,W0
0E04:  CP      W0,#2
0E06:  BRA     GT,E18
.................... 		if (c ==  0xFF){ 
0E08:  MOV     87E,W4
0E0A:  XOR     #FF,W4
0E0C:  BRA     NZ,E12
.................... 			SM_id++; 
0E0E:  INC.B   0814
.................... 		}else{ 
0E10:  BRA     E16
.................... 			SM_id = 1; 
0E12:  MOV.B   #1,W0L
0E14:  MOV.B   W0L,814
.................... 		} 
.................... 	}else if (SM_id <= 3){ 
0E16:  BRA     F4C
0E18:  MOV.B   814,W0L
0E1A:  SE      W0,W0
0E1C:  CP      W0,#3
0E1E:  BRA     GT,E2A
.................... 		if (c == 0x02){ 
0E20:  MOV     87E,W4
0E22:  CP      W4,#2
0E24:  BRA     NZ,E28
.................... 			SM_id++; 
0E26:  INC.B   0814
.................... 		} 
.................... 	}else if (SM_id <= 4){ 
0E28:  BRA     F4C
0E2A:  MOV.B   814,W0L
0E2C:  SE      W0,W0
0E2E:  CP      W0,#4
0E30:  BRA     GT,E3C
.................... 		if ( c == 0x06){ 
0E32:  MOV     87E,W4
0E34:  CP      W4,#6
0E36:  BRA     NZ,E3A
.................... 			SM_id++; 
0E38:  INC.B   0814
.................... 		} 
.................... 	}else if (SM_id > 4 && SM_id <= 6){ 
0E3A:  BRA     F4C
0E3C:  MOV.B   814,W0L
0E3E:  SE      W0,W0
0E40:  CP      W0,#4
0E42:  BRA     LE,E5E
0E44:  MOV.B   814,W0L
0E46:  SE      W0,W0
0E48:  CP      W0,#6
0E4A:  BRA     GT,E5E
.................... 		arrayDataXI[SM_id - 5] = c; 
0E4C:  MOV.B   814,W0L
0E4E:  SE      W0,W0
0E50:  SUB     W0,#5,W5
0E52:  MOV     #80C,W4
0E54:  ADD     W5,W4,W6
0E56:  MOV     87E,W0
0E58:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E5A:  INC.B   0814
.................... 	}else if (SM_id == 7){ 
0E5C:  BRA     F4C
0E5E:  MOV.B   814,W0L
0E60:  SE      W0,W0
0E62:  CP      W0,#7
0E64:  BRA     NZ,E78
.................... 		arrayData[SM_id - 7] = c; 
0E66:  MOV.B   814,W0L
0E68:  SE      W0,W0
0E6A:  SUB     W0,#7,W5
0E6C:  MOV     #806,W4
0E6E:  ADD     W5,W4,W6
0E70:  MOV     87E,W0
0E72:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E74:  INC.B   0814
.................... 	}else if (SM_id > 7 && SM_id <= 9){ 
0E76:  BRA     F4C
0E78:  MOV.B   814,W0L
0E7A:  SE      W0,W0
0E7C:  CP      W0,#7
0E7E:  BRA     LE,E9A
0E80:  MOV.B   814,W0L
0E82:  SE      W0,W0
0E84:  CP      W0,#9
0E86:  BRA     GT,E9A
.................... 		arrayDataYI[SM_id - 8] = c; 
0E88:  MOV.B   814,W0L
0E8A:  SE      W0,W0
0E8C:  SUB     W0,#8,W5
0E8E:  MOV     #810,W4
0E90:  ADD     W5,W4,W6
0E92:  MOV     87E,W0
0E94:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0E96:  INC.B   0814
.................... 	}else if (SM_id > 9 && SM_id <= 11){ 
0E98:  BRA     F4C
0E9A:  MOV.B   814,W0L
0E9C:  SE      W0,W0
0E9E:  CP      W0,#9
0EA0:  BRA     LE,EBC
0EA2:  MOV.B   814,W0L
0EA4:  SE      W0,W0
0EA6:  CP      W0,#B
0EA8:  BRA     GT,EBC
.................... 		arrayData[SM_id - 9] = c; 
0EAA:  MOV.B   814,W0L
0EAC:  SE      W0,W0
0EAE:  SUB     W0,#9,W5
0EB0:  MOV     #806,W4
0EB2:  ADD     W5,W4,W6
0EB4:  MOV     87E,W0
0EB6:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0EB8:  INC.B   0814
.................... 	}else if (SM_id > 11 && SM_id <= 13){ 
0EBA:  BRA     F4C
0EBC:  MOV.B   814,W0L
0EBE:  SE      W0,W0
0EC0:  CP      W0,#B
0EC2:  BRA     LE,EDE
0EC4:  MOV.B   814,W0L
0EC6:  SE      W0,W0
0EC8:  CP      W0,#D
0ECA:  BRA     GT,EDE
.................... 		arrayDataXII[SM_id - 12] = c; 
0ECC:  MOV.B   814,W0L
0ECE:  SE      W0,W0
0ED0:  SUB     W0,#C,W5
0ED2:  MOV     #80E,W4
0ED4:  ADD     W5,W4,W6
0ED6:  MOV     87E,W0
0ED8:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0EDA:  INC.B   0814
.................... 	}else if (SM_id == 14){ 
0EDC:  BRA     F4C
0EDE:  MOV.B   814,W0L
0EE0:  SE      W0,W0
0EE2:  CP      W0,#E
0EE4:  BRA     NZ,EF8
.................... 		arrayData[SM_id - 11] = c; 
0EE6:  MOV.B   814,W0L
0EE8:  SE      W0,W0
0EEA:  SUB     W0,#B,W5
0EEC:  MOV     #806,W4
0EEE:  ADD     W5,W4,W6
0EF0:  MOV     87E,W0
0EF2:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0EF4:  INC.B   0814
.................... 	}else if (SM_id > 14 && SM_id <= 16){ 
0EF6:  BRA     F4C
0EF8:  MOV.B   814,W0L
0EFA:  SE      W0,W0
0EFC:  CP      W0,#E
0EFE:  BRA     LE,F1A
0F00:  MOV.B   814,W0L
0F02:  SE      W0,W0
0F04:  CP      W0,#10
0F06:  BRA     GT,F1A
.................... 		arrayDataYII[SM_id - 15] = c; 
0F08:  MOV.B   814,W0L
0F0A:  SE      W0,W0
0F0C:  SUB     W0,#F,W5
0F0E:  MOV     #812,W4
0F10:  ADD     W5,W4,W6
0F12:  MOV     87E,W0
0F14:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0F16:  INC.B   0814
.................... 	}else if (SM_id > 16 && SM_id <= 18){ 
0F18:  BRA     F4C
0F1A:  MOV.B   814,W0L
0F1C:  SE      W0,W0
0F1E:  CP      W0,#10
0F20:  BRA     LE,F3C
0F22:  MOV.B   814,W0L
0F24:  SE      W0,W0
0F26:  CP      W0,#12
0F28:  BRA     GT,F3C
.................... 		arrayData[SM_id - 13] = c; 
0F2A:  MOV.B   814,W0L
0F2C:  SE      W0,W0
0F2E:  SUB     W0,#D,W5
0F30:  MOV     #806,W4
0F32:  ADD     W5,W4,W6
0F34:  MOV     87E,W0
0F36:  MOV.B   W0L,[W6+#0]
.................... 		SM_id++; 
0F38:  INC.B   0814
.................... 	}else if(SM_id > 18){ 
0F3A:  BRA     F4C
0F3C:  MOV.B   814,W0L
0F3E:  SE      W0,W0
0F40:  CP      W0,#12
0F42:  BRA     LE,F4C
.................... 		getPackage = 1; 
0F44:  MOV     #1,W4
0F46:  MOV     W4,816
.................... 		SM_id = 1; 
0F48:  MOV.B   #1,W0L
0F4A:  MOV.B   W0L,814
.................... 	} 
0F4C:  MOV     [--W15],W6
0F4E:  MOV     [--W15],W5
0F50:  RETURN  
.................... } 
....................  
....................  
.................... #INT_RDA               // receive data interrupt one time per one  
.................... void UART1_Isr() { 
0F52:  PUSH    42
0F54:  PUSH    36
0F56:  PUSH    32
0F58:  MOV     W0,[W15++]
0F5A:  MOV     #2,W0
0F5C:  REPEAT  #C
0F5E:  MOV     [W0++],[W15++]
0F60:  BTSS.B  222.0
0F62:  BRA     F60
0F64:  MOV     226,W0
0F66:  MOV.B   W0L,87C
0F68:  CLR.B   87D
....................     int c = getc(); 
....................     SM_RxD(c); 
0F6A:  PUSH    87C
0F6C:  POP     87E
0F6E:  CALL    DFC
0F72:  BCLR.B  85.3
0F74:  MOV     #1A,W0
0F76:  REPEAT  #C
0F78:  MOV     [--W15],[W0--]
0F7A:  MOV     [--W15],W0
0F7C:  POP     32
0F7E:  POP     36
0F80:  POP     42
0F82:  RETFIE  
.................... } 
....................  
.................... void control_inputX(int input, int direc){ 
*
1554:  MOV     W5,[W15++]
1556:  MOV     W6,[W15++]
1558:  MOV     W7,[W15++]
155A:  MOV     W8,[W15++]
.................... 	if(direc == 0){ 
155C:  CP0     854
155E:  BRA     NZ,15DE
.................... 		if(input >= 743 ){ 
1560:  MOV     852,W4
1562:  MOV     #2E7,W3
1564:  CP      W3,W4
1566:  BRA     GT,1576
.................... 			set_pwm_duty(1, 2000); 
1568:  MOV     #7D0,W4
156A:  MOV     W4,180
.................... 			output_bit(motorXI,1); //if 0, IN2->AXI@2 = clockwise  
156C:  BSET.B  2CC.0
156E:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,0); 
1570:  BCLR.B  2CC.1
1572:  BCLR.B  2C8.1
.................... 		}else if(input > 0 ){ 
1574:  BRA     15DC
1576:  MOV     852,W4
1578:  CP      W4,#0
157A:  BRA     LE,15D2
.................... 			set_pwm_duty(1, (int)((input/743.0f)*2000)); 
157C:  MOV     852,W0
157E:  CLR     W3
1580:  BTSC    W0.F
1582:  SETM    W3
1584:  MOV     W3,W1
1586:  MOV     W3,W2
1588:  CALL    1022
158C:  MOV     #0,W4
158E:  MOV     #0,W5
1590:  MOV     #3800,W6
1592:  MOV     #4087,W7
1594:  CALL    1086
1598:  MOV     W0,W5
159A:  MOV     W1,W6
159C:  MOV     W2,W7
159E:  MOV     W3,W8
15A0:  MOV     W5,[W15++]
15A2:  MOV     W6,[W15++]
15A4:  MOV     W7,[W15++]
15A6:  MOV     W5,W0
15A8:  MOV     W6,W1
15AA:  MOV     W7,W2
15AC:  MOV     W8,W3
15AE:  MOV     #0,W4
15B0:  MOV     #0,W5
15B2:  MOV     #4000,W6
15B4:  MOV     #409F,W7
15B6:  CALL    118E
15BA:  MOV     [--W15],W7
15BC:  MOV     [--W15],W6
15BE:  MOV     [--W15],W5
15C0:  CALL    129E
15C4:  MOV     W0,W5
15C6:  MOV     W5,180
.................... 			output_bit(motorXI,1); //if 0, IN2->AXI@2 = clockwise  
15C8:  BSET.B  2CC.0
15CA:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,0); 
15CC:  BCLR.B  2CC.1
15CE:  BCLR.B  2C8.1
.................... 		}else{ 
15D0:  BRA     15DC
.................... 			set_pwm_duty(1, 0); 
15D2:  CLR     180
.................... 			output_bit(motorXI,0); 
15D4:  BCLR.B  2CC.0
15D6:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,0); 
15D8:  BCLR.B  2CC.1
15DA:  BCLR.B  2C8.1
.................... 			} 
.................... 	}	 
15DC:  BRA     1660
.................... 	else if(direc == 1){ 
15DE:  MOV     854,W4
15E0:  CP      W4,#1
15E2:  BRA     NZ,1660
.................... 		if(input >= 743 ){ 
15E4:  MOV     852,W4
15E6:  MOV     #2E7,W3
15E8:  CP      W3,W4
15EA:  BRA     GT,15FA
.................... 			set_pwm_duty(1, 2000); 
15EC:  MOV     #7D0,W4
15EE:  MOV     W4,180
.................... 			output_bit(motorXI,0); //if 0, IN2->AXI@2 = clockwise  
15F0:  BCLR.B  2CC.0
15F2:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,1); 
15F4:  BSET.B  2CC.1
15F6:  BCLR.B  2C8.1
.................... 		}else if(input > 0 ){ 
15F8:  BRA     1660
15FA:  MOV     852,W4
15FC:  CP      W4,#0
15FE:  BRA     LE,1656
.................... 			set_pwm_duty(1, (int)((input/743.0f)*2000)); 
1600:  MOV     852,W0
1602:  CLR     W3
1604:  BTSC    W0.F
1606:  SETM    W3
1608:  MOV     W3,W1
160A:  MOV     W3,W2
160C:  CALL    1022
1610:  MOV     #0,W4
1612:  MOV     #0,W5
1614:  MOV     #3800,W6
1616:  MOV     #4087,W7
1618:  CALL    1086
161C:  MOV     W0,W5
161E:  MOV     W1,W6
1620:  MOV     W2,W7
1622:  MOV     W3,W8
1624:  MOV     W5,[W15++]
1626:  MOV     W6,[W15++]
1628:  MOV     W7,[W15++]
162A:  MOV     W5,W0
162C:  MOV     W6,W1
162E:  MOV     W7,W2
1630:  MOV     W8,W3
1632:  MOV     #0,W4
1634:  MOV     #0,W5
1636:  MOV     #4000,W6
1638:  MOV     #409F,W7
163A:  CALL    118E
163E:  MOV     [--W15],W7
1640:  MOV     [--W15],W6
1642:  MOV     [--W15],W5
1644:  CALL    129E
1648:  MOV     W0,W5
164A:  MOV     W5,180
.................... 			output_bit(motorXI,0); //if 0, IN2->AXI@2 = clockwise  
164C:  BCLR.B  2CC.0
164E:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,1); 
1650:  BSET.B  2CC.1
1652:  BCLR.B  2C8.1
.................... 		}else{ 
1654:  BRA     1660
.................... 			set_pwm_duty(1, 0); 
1656:  CLR     180
.................... 			output_bit(motorXI,0); 
1658:  BCLR.B  2CC.0
165A:  BCLR.B  2C8.0
.................... 			output_bit(motorXII,0); 
165C:  BCLR.B  2CC.1
165E:  BCLR.B  2C8.1
.................... 		} 
.................... 	}		 
1660:  MOV     [--W15],W8
1662:  MOV     [--W15],W7
1664:  MOV     [--W15],W6
1666:  MOV     [--W15],W5
1668:  RETURN  
.................... } 
....................  
....................  
.................... void control_inputY(int input, int direc){ 
*
12F4:  MOV     W5,[W15++]
12F6:  MOV     W6,[W15++]
12F8:  MOV     W7,[W15++]
12FA:  MOV     W8,[W15++]
.................... 	 
.................... if(direc == 0){ 
12FC:  CP0     854
12FE:  BRA     NZ,137E
.................... 		if(input >= 743 ){ 
1300:  MOV     852,W4
1302:  MOV     #2E7,W3
1304:  CP      W3,W4
1306:  BRA     GT,1316
.................... 			set_pwm_duty(2, 2000); 
1308:  MOV     #7D0,W4
130A:  MOV     W4,186
.................... 			output_bit(motorYI,1); //if 0, IN2->AXI@2 = clockwise  
130C:  BSET.B  2C4.2
130E:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,0); 
1310:  BCLR.B  2C4.4
1312:  BCLR.B  2C0.4
.................... 		}else if(input > 0 ){ 
1314:  BRA     137C
1316:  MOV     852,W4
1318:  CP      W4,#0
131A:  BRA     LE,1372
.................... 			set_pwm_duty(2, (int)((input/743.0f)*2000)); 
131C:  MOV     852,W0
131E:  CLR     W3
1320:  BTSC    W0.F
1322:  SETM    W3
1324:  MOV     W3,W1
1326:  MOV     W3,W2
1328:  CALL    1022
132C:  MOV     #0,W4
132E:  MOV     #0,W5
1330:  MOV     #3800,W6
1332:  MOV     #4087,W7
1334:  CALL    1086
1338:  MOV     W0,W5
133A:  MOV     W1,W6
133C:  MOV     W2,W7
133E:  MOV     W3,W8
1340:  MOV     W5,[W15++]
1342:  MOV     W6,[W15++]
1344:  MOV     W7,[W15++]
1346:  MOV     W5,W0
1348:  MOV     W6,W1
134A:  MOV     W7,W2
134C:  MOV     W8,W3
134E:  MOV     #0,W4
1350:  MOV     #0,W5
1352:  MOV     #4000,W6
1354:  MOV     #409F,W7
1356:  CALL    118E
135A:  MOV     [--W15],W7
135C:  MOV     [--W15],W6
135E:  MOV     [--W15],W5
1360:  CALL    129E
1364:  MOV     W0,W5
1366:  MOV     W5,186
.................... 			output_bit(motorYI,1); //if 0, IN2->AXI@2 = clockwise  
1368:  BSET.B  2C4.2
136A:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,0); 
136C:  BCLR.B  2C4.4
136E:  BCLR.B  2C0.4
.................... 		}else{ 
1370:  BRA     137C
.................... 			set_pwm_duty(2, 0); 
1372:  CLR     186
.................... 			output_bit(motorYI,0); 
1374:  BCLR.B  2C4.2
1376:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,0); 
1378:  BCLR.B  2C4.4
137A:  BCLR.B  2C0.4
.................... 			} 
.................... 	}	 
137C:  BRA     1400
.................... 	else if(direc == 1){ 
137E:  MOV     854,W4
1380:  CP      W4,#1
1382:  BRA     NZ,1400
.................... 		if(input >= 743 ){ 
1384:  MOV     852,W4
1386:  MOV     #2E7,W3
1388:  CP      W3,W4
138A:  BRA     GT,139A
.................... 			set_pwm_duty(2, 2000); 
138C:  MOV     #7D0,W4
138E:  MOV     W4,186
.................... 			output_bit(motorYI,0); //if 0, IN2->AXI@2 = clockwise  
1390:  BCLR.B  2C4.2
1392:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,1); 
1394:  BSET.B  2C4.4
1396:  BCLR.B  2C0.4
.................... 		}else if(input > 0 ){ 
1398:  BRA     1400
139A:  MOV     852,W4
139C:  CP      W4,#0
139E:  BRA     LE,13F6
.................... 			set_pwm_duty(2, (int)((input/743.0f)*2000)); 
13A0:  MOV     852,W0
13A2:  CLR     W3
13A4:  BTSC    W0.F
13A6:  SETM    W3
13A8:  MOV     W3,W1
13AA:  MOV     W3,W2
13AC:  CALL    1022
13B0:  MOV     #0,W4
13B2:  MOV     #0,W5
13B4:  MOV     #3800,W6
13B6:  MOV     #4087,W7
13B8:  CALL    1086
13BC:  MOV     W0,W5
13BE:  MOV     W1,W6
13C0:  MOV     W2,W7
13C2:  MOV     W3,W8
13C4:  MOV     W5,[W15++]
13C6:  MOV     W6,[W15++]
13C8:  MOV     W7,[W15++]
13CA:  MOV     W5,W0
13CC:  MOV     W6,W1
13CE:  MOV     W7,W2
13D0:  MOV     W8,W3
13D2:  MOV     #0,W4
13D4:  MOV     #0,W5
13D6:  MOV     #4000,W6
13D8:  MOV     #409F,W7
13DA:  CALL    118E
13DE:  MOV     [--W15],W7
13E0:  MOV     [--W15],W6
13E2:  MOV     [--W15],W5
13E4:  CALL    129E
13E8:  MOV     W0,W5
13EA:  MOV     W5,186
.................... 			output_bit(motorYI,0); //if 0, IN2->AXI@2 = clockwise  
13EC:  BCLR.B  2C4.2
13EE:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,1); 
13F0:  BSET.B  2C4.4
13F2:  BCLR.B  2C0.4
.................... 		}else{ 
13F4:  BRA     1400
.................... 			set_pwm_duty(2, 0); 
13F6:  CLR     186
.................... 			output_bit(motorYI,0); 
13F8:  BCLR.B  2C4.2
13FA:  BCLR.B  2C0.2
.................... 			output_bit(motorYII,0); 
13FC:  BCLR.B  2C4.4
13FE:  BCLR.B  2C0.4
.................... 			 
.................... 		}		 
.................... 	} 
1400:  MOV     [--W15],W8
1402:  MOV     [--W15],W7
1404:  MOV     [--W15],W6
1406:  MOV     [--W15],W5
1408:  RETURN  
.................... } 
....................  
.................... void control_inputZ(int input, int direc){ 
140A:  MOV     W5,[W15++]
140C:  MOV     W6,[W15++]
140E:  MOV     W7,[W15++]
1410:  MOV     W8,[W15++]
.................... 	if(direc == 0){ 
1412:  CP0     854
1414:  BRA     NZ,1494
.................... 		if(input >= 743 ){ 
1416:  MOV     852,W4
1418:  MOV     #2E7,W3
141A:  CP      W3,W4
141C:  BRA     GT,142C
.................... 			set_pwm_duty(3, 2000); 
141E:  MOV     #7D0,W4
1420:  MOV     W4,18C
.................... 			output_bit(motorZI,1); //if 0, IN2->AXI@2 = clockwise  
1422:  BSET.B  2C4.0
1424:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,0); 
1426:  BCLR.B  2C4.1
1428:  BCLR.B  2C0.1
.................... 		}else if(input > 0 ){ 
142A:  BRA     1492
142C:  MOV     852,W4
142E:  CP      W4,#0
1430:  BRA     LE,1488
.................... 			set_pwm_duty(3, (int)((input/743.0f)*2000)); 
1432:  MOV     852,W0
1434:  CLR     W3
1436:  BTSC    W0.F
1438:  SETM    W3
143A:  MOV     W3,W1
143C:  MOV     W3,W2
143E:  CALL    1022
1442:  MOV     #0,W4
1444:  MOV     #0,W5
1446:  MOV     #3800,W6
1448:  MOV     #4087,W7
144A:  CALL    1086
144E:  MOV     W0,W5
1450:  MOV     W1,W6
1452:  MOV     W2,W7
1454:  MOV     W3,W8
1456:  MOV     W5,[W15++]
1458:  MOV     W6,[W15++]
145A:  MOV     W7,[W15++]
145C:  MOV     W5,W0
145E:  MOV     W6,W1
1460:  MOV     W7,W2
1462:  MOV     W8,W3
1464:  MOV     #0,W4
1466:  MOV     #0,W5
1468:  MOV     #4000,W6
146A:  MOV     #409F,W7
146C:  CALL    118E
1470:  MOV     [--W15],W7
1472:  MOV     [--W15],W6
1474:  MOV     [--W15],W5
1476:  CALL    129E
147A:  MOV     W0,W5
147C:  MOV     W5,18C
.................... 			output_bit(motorZI,1); //if 0, IN2->AXI@2 = clockwise  
147E:  BSET.B  2C4.0
1480:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,0); 
1482:  BCLR.B  2C4.1
1484:  BCLR.B  2C0.1
.................... 		}else{ 
1486:  BRA     1492
.................... 			set_pwm_duty(3, 0);				 
1488:  CLR     18C
.................... 			output_bit(motorZI,0); 
148A:  BCLR.B  2C4.0
148C:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,0); 
148E:  BCLR.B  2C4.1
1490:  BCLR.B  2C0.1
.................... 				} 
.................... 	}	 
1492:  BRA     1516
.................... 	else if(direc == 1){ 
1494:  MOV     854,W4
1496:  CP      W4,#1
1498:  BRA     NZ,1516
.................... 		if(input >= 743 ){ 
149A:  MOV     852,W4
149C:  MOV     #2E7,W3
149E:  CP      W3,W4
14A0:  BRA     GT,14B0
.................... 			set_pwm_duty(3, 2000); 
14A2:  MOV     #7D0,W4
14A4:  MOV     W4,18C
.................... 			output_bit(motorZI,0); //if 0, IN2->AXI@2 = clockwise  
14A6:  BCLR.B  2C4.0
14A8:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,1); 
14AA:  BSET.B  2C4.1
14AC:  BCLR.B  2C0.1
.................... 		}else if(input > 0 ){ 
14AE:  BRA     1516
14B0:  MOV     852,W4
14B2:  CP      W4,#0
14B4:  BRA     LE,150C
.................... 			set_pwm_duty(3, (int)((input/743.0f)*2000)); 
14B6:  MOV     852,W0
14B8:  CLR     W3
14BA:  BTSC    W0.F
14BC:  SETM    W3
14BE:  MOV     W3,W1
14C0:  MOV     W3,W2
14C2:  CALL    1022
14C6:  MOV     #0,W4
14C8:  MOV     #0,W5
14CA:  MOV     #3800,W6
14CC:  MOV     #4087,W7
14CE:  CALL    1086
14D2:  MOV     W0,W5
14D4:  MOV     W1,W6
14D6:  MOV     W2,W7
14D8:  MOV     W3,W8
14DA:  MOV     W5,[W15++]
14DC:  MOV     W6,[W15++]
14DE:  MOV     W7,[W15++]
14E0:  MOV     W5,W0
14E2:  MOV     W6,W1
14E4:  MOV     W7,W2
14E6:  MOV     W8,W3
14E8:  MOV     #0,W4
14EA:  MOV     #0,W5
14EC:  MOV     #4000,W6
14EE:  MOV     #409F,W7
14F0:  CALL    118E
14F4:  MOV     [--W15],W7
14F6:  MOV     [--W15],W6
14F8:  MOV     [--W15],W5
14FA:  CALL    129E
14FE:  MOV     W0,W5
1500:  MOV     W5,18C
.................... 			output_bit(motorZI,0); //if 0, IN2->AXI@2 = clockwise  
1502:  BCLR.B  2C4.0
1504:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,1); 
1506:  BSET.B  2C4.1
1508:  BCLR.B  2C0.1
.................... 		}else{ 
150A:  BRA     1516
.................... 			set_pwm_duty(3, 0); 
150C:  CLR     18C
.................... 			output_bit(motorZI,0); 
150E:  BCLR.B  2C4.0
1510:  BCLR.B  2C0.0
.................... 			output_bit(motorZII,0); 
1512:  BCLR.B  2C4.1
1514:  BCLR.B  2C0.1
.................... 				 
.................... 			}		 
.................... 		} 
1516:  MOV     [--W15],W8
1518:  MOV     [--W15],W7
151A:  MOV     [--W15],W6
151C:  MOV     [--W15],W5
151E:  RETURN  
.................... 	} 
....................  
.................... void move_posX(int pulse_x, int direc){ 
*
172C:  MOV     W5,[W15++]
172E:  MOV     #1,W4
1730:  MOV     W4,84A
.................... 	int check = 1; 
.................... 	while(check == 1){   
1732:  MOV     84A,W4
1734:  CP      W4,#1
1736:  BRA     NZ,1774
.................... 		int error = pulse_x - countX; 
1738:  MOV     846,W4
173A:  MOV     800,W3
173C:  SUB     W4,W3,W0
173E:  MOV     W0,84C
.................... 			error *= 5; 
1740:  MOV     84C,W4
1742:  MUL.UU  W4,#5,W0
1744:  MOV     W0,84C
.................... 		//printf("error:%d\n",error); 
.................... 		//delay_ms(10); 
....................  
.................... 		if(abs(error) <= tolerance){ 
1746:  MOV     84C,W0
1748:  BTSS    W0.F
174A:  BRA     1752
174C:  MOV     #0,W4
174E:  MOV     84C,W3
1750:  SUB     W4,W3,W0
1752:  MOV     W0,W5
1754:  CP      W5,#1E
1756:  BRA     GT,1766
.................... 			control_inputX(0,direc); 
1758:  CLR     852
175A:  PUSH    848
175C:  POP     854
175E:  CALL    1554
.................... 			check = 0;	 
1762:  CLR     84A
.................... 		}else{ 
1764:  BRA     1772
.................... 			control_inputX(error, direc);  
1766:  PUSH    84C
1768:  POP     852
176A:  PUSH    848
176C:  POP     854
176E:  CALL    1554
.................... 			 
.................... 			 
.................... 		} 
1772:  BRA     1732
.................... 	} 
1774:  MOV     [--W15],W5
1776:  RETURN  
.................... } 
....................  
.................... void move_posY(int pulse_y, int direc){ 
1778:  MOV     W5,[W15++]
177A:  MOV     #1,W4
177C:  MOV     W4,84A
.................... 	int check = 1; 
.................... 	while(check == 1){ 
177E:  MOV     84A,W4
1780:  CP      W4,#1
1782:  BRA     NZ,17BA
.................... 		int error = pulse_y - countY; 
1784:  MOV     846,W4
1786:  MOV     802,W3
1788:  SUB     W4,W3,W0
178A:  MOV     W0,84C
.................... 		if(abs(error) <= tolerance){ 
178C:  MOV     84C,W0
178E:  BTSS    W0.F
1790:  BRA     1798
1792:  MOV     #0,W4
1794:  MOV     84C,W3
1796:  SUB     W4,W3,W0
1798:  MOV     W0,W5
179A:  CP      W5,#1E
179C:  BRA     GT,17AC
.................... 			control_inputY(0, direc); 
179E:  CLR     852
17A0:  PUSH    848
17A2:  POP     854
17A4:  CALL    12F4
.................... 			check = 0;	 
17A8:  CLR     84A
.................... 		}else{ 
17AA:  BRA     17B8
.................... 			control_inputY(error, direc);  
17AC:  PUSH    84C
17AE:  POP     852
17B0:  PUSH    848
17B2:  POP     854
17B4:  CALL    12F4
.................... 		} 
17B8:  BRA     177E
.................... 	} 
17BA:  MOV     [--W15],W5
17BC:  RETURN  
.................... } 
....................  
....................  
.................... void move_posZ(int pulse_z, int direc){ 
*
16E6:  MOV     W5,[W15++]
16E8:  MOV     #1,W4
16EA:  MOV     W4,84A
.................... 	int check = 1; 
.................... 	while(check == 1){ 
16EC:  MOV     84A,W4
16EE:  CP      W4,#1
16F0:  BRA     NZ,1728
.................... 	int error = pulse_z - countZ; 
16F2:  MOV     846,W4
16F4:  MOV     804,W3
16F6:  SUB     W4,W3,W0
16F8:  MOV     W0,84C
.................... 		if(abs(error) <= tolerance){ 
16FA:  MOV     84C,W0
16FC:  BTSS    W0.F
16FE:  BRA     1706
1700:  MOV     #0,W4
1702:  MOV     84C,W3
1704:  SUB     W4,W3,W0
1706:  MOV     W0,W5
1708:  CP      W5,#1E
170A:  BRA     GT,171A
.................... 			control_inputZ(0, direc);	 
170C:  CLR     852
170E:  PUSH    848
1710:  POP     854
1712:  CALL    140A
.................... 			check = 0; 
1716:  CLR     84A
.................... 		}else{ 
1718:  BRA     1726
.................... 			control_inputZ(error, direc); 
171A:  PUSH    84C
171C:  POP     852
171E:  PUSH    848
1720:  POP     854
1722:  CALL    140A
.................... 		}  
1726:  BRA     16EC
.................... 	} 
1728:  MOV     [--W15],W5
172A:  RETURN  
.................... } 
....................  
....................  
.................... void set_Z(void){ 
*
1520:  MOV     W5,[W15++]
1522:  MOV     #1,W4
1524:  MOV     W4,830
.................... 	int check = 1; 
.................... 	while(check == 1){  
1526:  MOV     830,W4
1528:  CP      W4,#1
152A:  BRA     NZ,1550
.................... 		if(input(lim_SW_Z) == 1){ 
152C:  BSET.B  2C8.5
152E:  BTSS.B  2CA.5
1530:  BRA     153E
.................... 			control_inputZ(0, 0); 
1532:  CLR     852
1534:  CLR     854
1536:  CALL    140A
.................... 			check = 0; 
153A:  CLR     830
.................... 		}else if(input(lim_SW_Z) == 0){ 
153C:  BRA     154E
153E:  BSET.B  2C8.5
1540:  BTSC.B  2CA.5
1542:  BRA     154E
.................... 			control_inputZ(700, 0); 
1544:  MOV     #2BC,W4
1546:  MOV     W4,852
1548:  CLR     854
154A:  CALL    140A
.................... 		} 
154E:  BRA     1526
.................... 	} 
1550:  MOV     [--W15],W5
1552:  RETURN  
.................... } 
....................  
....................  
.................... void set_Zero(void){ 
*
166A:  MOV     W5,[W15++]
166C:  MOV     #1,W4
166E:  MOV     W4,82A
1670:  CLR     82C
.................... 	int loop = 1; 
.................... 	int stateSWII = 0; 
.................... 	while(loop == 1){ 
1672:  MOV     82A,W4
1674:  CP      W4,#1
1676:  BRA     NZ,16E2
.................... 		if(stateSWII == 0){ 
1678:  CP0     82C
167A:  BRA     NZ,16A2
.................... 			if(input(lim_SW_Y) == 1){ 
167C:  BSET.B  2C8.4
167E:  BTSS.B  2CA.4
1680:  BRA     1690
.................... 				control_inputY(0,1); 
1682:  CLR     852
1684:  MOV     #1,W4
1686:  MOV     W4,854
1688:  CALL    12F4
.................... 				stateSWII++; 
168C:  INC     082C
.................... 			}else if(input(lim_SW_Y) == 0){ 
168E:  BRA     16A0
1690:  BSET.B  2C8.4
1692:  BTSC.B  2CA.4
1694:  BRA     16A0
.................... 				control_inputY(700,0); 
1696:  MOV     #2BC,W4
1698:  MOV     W4,852
169A:  CLR     854
169C:  CALL    12F4
.................... 			} 
.................... 		}else if(stateSWII == 1){   
16A0:  BRA     16E0
16A2:  MOV     82C,W4
16A4:  CP      W4,#1
16A6:  BRA     NZ,16B8
.................... 			set_pwm_duty(4, 90); 
16A8:  MOV     #5A,W4
16AA:  MOV     W4,192
.................... 			set_pwm_duty(5, 150); 
16AC:  MOV     #96,W4
16AE:  MOV     W4,198
.................... 			set_Z(); 
16B0:  CALL    1520
.................... 			stateSWII++; 
16B4:  INC     082C
.................... 		}else if(stateSWII == 2){   
16B6:  BRA     16E0
16B8:  MOV     82C,W4
16BA:  CP      W4,#2
16BC:  BRA     NZ,16E0
.................... 			if(input(lim_SW_X) == 1){ 
16BE:  BSET.B  2C9.6
16C0:  BTSS.B  2CB.6
16C2:  BRA     16D0
.................... 				control_inputX(0,0); 
16C4:  CLR     852
16C6:  CLR     854
16C8:  CALL    1554
.................... 				loop=0; 
16CC:  CLR     82A
.................... 			}else if(input(lim_SW_X) == 0){ 
16CE:  BRA     16E0
16D0:  BSET.B  2C9.6
16D2:  BTSC.B  2CB.6
16D4:  BRA     16E0
.................... 				control_inputX(700,0); 
16D6:  MOV     #2BC,W4
16D8:  MOV     W4,852
16DA:  CLR     854
16DC:  CALL    1554
.................... 			} 
.................... 		} 
16E0:  BRA     1672
.................... 	}  
16E2:  MOV     [--W15],W5
16E4:  RETURN  
.................... } 
....................  
.................... void moveXYZ(int x, int direcX, int y, int direcY, int z, int direcZ){ 
*
17BE:  MOV     #1,W4
17C0:  MOV     W4,836
17C2:  CLR     838
....................  
.................... int loop = 1; 
.................... int stateSWIII = 0; 
.................... 	while(loop == 1){ 
17C4:  MOV     836,W4
17C6:  CP      W4,#1
17C8:  BRA     NZ,1810
.................... 		if(stateSWIII == 0){ 
17CA:  CP0     838
17CC:  BRA     NZ,17E0
.................... 			move_posX(x, direcX); 
17CE:  PUSH    82A
17D0:  POP     846
17D2:  PUSH    82C
17D4:  POP     848
17D6:  CALL    172C
.................... 			stateSWIII = 1; 
17DA:  MOV     #1,W4
17DC:  MOV     W4,838
.................... 		}else if(stateSWIII == 1){   
17DE:  BRA     180E
17E0:  MOV     838,W4
17E2:  CP      W4,#1
17E4:  BRA     NZ,17F8
.................... 			move_posY(y, direcY); 
17E6:  PUSH    82E
17E8:  POP     846
17EA:  PUSH    830
17EC:  POP     848
17EE:  CALL    1778
.................... 			stateSWIII = 2; 
17F2:  MOV     #2,W4
17F4:  MOV     W4,838
.................... 		}else if(stateSWIII == 2){   
17F6:  BRA     180E
17F8:  MOV     838,W4
17FA:  CP      W4,#2
17FC:  BRA     NZ,180E
.................... 			move_posZ(z, direcZ); 
17FE:  PUSH    832
1800:  POP     846
1802:  PUSH    834
1804:  POP     848
1806:  CALL    16E6
.................... 			stateSWIII = 0; 
180A:  CLR     838
.................... 			loop = 0; 
180C:  CLR     836
.................... 		} 
180E:  BRA     17C4
.................... 	}  
1810:  RETURN  
.................... }	 
....................  
.................... void servo_Top(int degress){ 
.................... 	for(int i = 90;i <= degress;i+=5){ 
.................... 		set_pwm_duty(4, i); 
.................... 		delay_ms(100); 
.................... 	} 
.................... } 
....................  
.................... void servo_Under(int degress){ 
.................... 	for(int i = 100;i <= degress;i+=5){ 
.................... 		set_pwm_duty(5, i); 
.................... 		delay_ms(100); 
.................... 	} 
.................... } 
....................  
.................... #INT_EXT0 
.................... void INT_EXT_INPUT0 (void) 
*
0F84:  PUSH    42
0F86:  PUSH    36
0F88:  PUSH    32
0F8A:  MOV     W0,[W15++]
0F8C:  MOV     #2,W0
0F8E:  REPEAT  #C
0F90:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countX++; 
0F92:  INC     0800
.................... } 
0F94:  BCLR.B  84.0
0F96:  MOV     #1A,W0
0F98:  REPEAT  #C
0F9A:  MOV     [--W15],[W0--]
0F9C:  MOV     [--W15],W0
0F9E:  POP     32
0FA0:  POP     36
0FA2:  POP     42
0FA4:  RETFIE  
.................... #INT_EXT1 
.................... void INT_EXT_INPUT1 (void) 
0FA6:  PUSH    42
0FA8:  PUSH    36
0FAA:  PUSH    32
0FAC:  MOV     W0,[W15++]
0FAE:  MOV     #2,W0
0FB0:  REPEAT  #C
0FB2:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countY++; 
0FB4:  INC     0802
.................... } 
0FB6:  BCLR.B  86.4
0FB8:  MOV     #1A,W0
0FBA:  REPEAT  #C
0FBC:  MOV     [--W15],[W0--]
0FBE:  MOV     [--W15],W0
0FC0:  POP     32
0FC2:  POP     36
0FC4:  POP     42
0FC6:  RETFIE  
.................... #INT_EXT2 
.................... void INT_EXT_INPUT2 (void) 
0FC8:  PUSH    42
0FCA:  PUSH    36
0FCC:  PUSH    32
0FCE:  MOV     W0,[W15++]
0FD0:  MOV     #2,W0
0FD2:  REPEAT  #C
0FD4:  MOV     [W0++],[W15++]
.................... {	 
.................... 		countZ++; 
0FD6:  INC     0804
0FD8:  BCLR.B  87.5
0FDA:  MOV     #1A,W0
0FDC:  REPEAT  #C
0FDE:  MOV     [--W15],[W0--]
0FE0:  MOV     [--W15],W0
0FE2:  POP     32
0FE4:  POP     36
0FE6:  POP     42
0FE8:  RETFIE  
.................... } 
.................... void Init_Interrupts() 
.................... { 
.................... 	disable_interrupts(GLOBAL); 
0FEA:  BCLR.B  81.7
0FEC:  MOV     #E0,W4
0FEE:  MOV     W4,42
0FF0:  BSET.B  81.7
.................... 	 
.................... 	clear_interrupt(INT_RDA);   // recommend style coding to confirm everything clear before use 
0FF2:  REPEAT  #3
0FF4:  MOV     226,W0
0FF6:  BCLR.B  85.3
....................     enable_interrupts(INT_RDA); 
0FF8:  BSET.B  95.3
....................  
.................... 	enable_interrupts( INT_EXT0 ); 
0FFA:  BSET.B  94.0
.................... 	ext_int_edge( 0, L_TO_H ) ; 
0FFC:  BCLR.B  82.0
....................  
.................... 	enable_interrupts( INT_EXT1 ); 
0FFE:  BSET.B  96.4
.................... 	ext_int_edge( 1, L_TO_H ) ; 
1000:  BCLR.B  82.1
....................  
.................... 	enable_interrupts( INT_EXT2 ); 
1002:  BSET.B  97.5
.................... 	ext_int_edge( 2, L_TO_H ) ; 
1004:  BCLR.B  82.2
.................... 	 
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_64 ,5000); 
1006:  CLR     110
1008:  MOV     #1388,W4
100A:  MOV     W4,10C
100C:  MOV     #8020,W4
100E:  MOV     W4,110
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_8 ,TIME_PERIOD); 
1010:  CLR     112
1012:  MOV     #7D0,W4
1014:  MOV     W4,10E
1016:  MOV     #8010,W4
1018:  MOV     W4,112
....................  
....................  
.................... 	enable_interrupts(GLOBAL); 
101A:  BCLR.B  81.7
101C:  CLR     42
101E:  BSET.B  81.7
1020:  RETURN  
....................  
.................... } 
....................  
.................... void main(){ 
*
1822:  MOV     #2780,W15
1824:  MOV     #27FF,W0
1826:  MOV     W0,20
1828:  NOP     
182A:  MOV     #4444,W0
182C:  MOV     W0,A8
182E:  BSET.B  81.7
1830:  MOV     #46,W0
1832:  MOV.B   W0L,742
1834:  MOV     #57,W0
1836:  MOV.B   W0L,742
1838:  BCLR.B  742.6
183A:  MOV     #63F,W0
183C:  MOV     W0,680
183E:  MOV     #3F03,W0
1840:  MOV     W0,682
1842:  MOV     #3F0C,W0
1844:  MOV     W0,6A4
1846:  MOV     #12,W0
1848:  MOV     W0,6C2
184A:  MOV     #1315,W0
184C:  MOV     W0,6C8
184E:  MOV     #14,W0
1850:  MOV     W0,6CA
1852:  MOV     #300,W0
1854:  MOV     W0,6CC
1856:  MOV     #1600,W0
1858:  MOV     W0,6CE
185A:  MOV     #46,W0
185C:  MOV.B   W0L,742
185E:  MOV     #57,W0
1860:  MOV.B   W0L,742
1862:  BSET.B  742.6
1864:  CLR     744
1866:  MOV     #8000,W4
1868:  MOV     W4,220
186A:  MOV     #400,W4
186C:  MOV     W4,222
186E:  BSET.B  220.3
1870:  MOV     #22,W4
1872:  MOV     W4,228
1874:  CLR     800
1876:  CLR     802
1878:  CLR     804
187A:  MOV.B   #1,W0L
187C:  MOV.B   W0L,814
187E:  CLR     816
1880:  SETM    32C
1882:  CLR     806
1884:  CLR     808
1886:  CLR     80A
1888:  CLR     80C
188A:  CLR     80E
188C:  CLR     810
188E:  CLR     812
.................... 	Init_Interrupts(); 
1890:  CALL    FEA
....................  
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 
1894:  MOV     #E,W4
1896:  MOV     W4,184
.................... 	setup_compare(2, COMPARE_PWM | COMPARE_TIMER3); 
1898:  MOV     #E,W4
189A:  MOV     W4,18A
.................... 	setup_compare(3, COMPARE_PWM | COMPARE_TIMER3); 
189C:  MOV     #E,W4
189E:  MOV     W4,190
....................  
.................... 	setup_compare(4, COMPARE_PWM | COMPARE_TIMER2); 
18A0:  MOV     #6,W4
18A2:  MOV     W4,196
.................... 	setup_compare(5, COMPARE_PWM | COMPARE_TIMER2); 
18A4:  MOV     #6,W4
18A6:  MOV     W4,19C
.................... 	set_Zero(); 
18A8:  CALL    166A
.................... 	int stateII = 0; 
.................... 	int stateAll =0; 
18AC:  CLR     818
18AE:  CLR     81A
.................... 	while(TRUE){ 
.................... 			//set_pwm_duty(5, 90);//for 5,up is 250,down is 100 ServoTop 
.................... 			//if(stateI == 0){ 
.................... 			/*if(stateII ==0){ 
.................... 			for(int i=600;i>0;i-=10){ 
.................... 			set_pwm_duty(4, i);//for 4,up is 580,down is 80, center is 330 ServoUnder 
.................... 			printf("i: %d\n",i); 
.................... 			delay_ms(1000); 
.................... 			}stateII++; 
.................... 			}*/ 
.................... 			//} z => base is 7680+7680+1536+768 = 17664, groud is 20736, 13824,  3390 top on box 
.................... 		int bagPosX, bagPosY, goPosX, goPosY; 
.................... 		if (getPackage >= 1){ 
18B0:  MOV     816,W4
18B2:  CP      W4,#1
18B4:  BRA     LT,198C
.................... 			getPackage = 0; 
18B6:  CLR     816
.................... 			memcpy(&bagPosX, arrayDataXI, sizeof(bagPosX)); 
18B8:  MOV     #81C,W1
18BA:  MOV     #80C,W2
18BC:  REPEAT  #1
18BE:  MOV.B   [W2++],[W1++]
.................... 			memcpy(&bagPosY, arrayDataYI, sizeof(bagPosY)); 
18C0:  MOV     #81E,W1
18C2:  MOV     #810,W2
18C4:  REPEAT  #1
18C6:  MOV.B   [W2++],[W1++]
.................... 			memcpy(&goPosX, arrayDataXII, sizeof(goPosX)); 
18C8:  MOV     #820,W1
18CA:  MOV     #80E,W2
18CC:  REPEAT  #1
18CE:  MOV.B   [W2++],[W1++]
.................... 			memcpy(&goPosY, arrayDataYII, sizeof(goPosY)); 
18D0:  MOV     #822,W1
18D2:  MOV     #812,W2
18D4:  REPEAT  #1
18D6:  MOV.B   [W2++],[W1++]
....................  
.................... 			move_posZ(7680, 1); 
18D8:  MOV     #1E00,W4
18DA:  MOV     W4,846
18DC:  MOV     #1,W4
18DE:  MOV     W4,848
18E0:  CALL    16E6
....................  
.................... 			while(stateAll==0){ 
18E4:  CP0     81A
18E6:  BRA     NZ,198C
.................... 				countX = 0; 
18E8:  CLR     800
.................... 				countY = 0; 
18EA:  CLR     802
.................... 				countZ = 0; 
18EC:  CLR     804
.................... 			 
.................... 			if(stateII == 0){ 
18EE:  CP0     818
18F0:  BRA     NZ,1920
.................... 				moveXYZ(bagPosX, arrayData[0], bagPosY, arrayData[1], 3000, 1); 
18F2:  MOV.B   806,W0L
18F4:  MOV.B   W0L,8
18F6:  SE      W4,W3
18F8:  MOV     W3,82C
18FA:  MOV.B   807,W0L
18FC:  MOV.B   W0L,W3L
18FE:  SE      W3,W2
1900:  MOV     W2,830
1902:  PUSH    81C
1904:  POP     82A
1906:  PUSH    81E
1908:  POP     82E
190A:  MOV     #BB8,W2
190C:  MOV     W2,832
190E:  MOV     #1,W2
1910:  MOV     W2,834
1912:  CALL    17BE
.................... 				//servo_Top(300); //arrayData[2] 
.................... 				//servo_Under(250); 
.................... 				delay_ms(3000);  
1916:  MOV     #BB8,W0
1918:  CALL    1812
.................... 				stateII++; 
191C:  INC     0818
.................... 				 
.................... 			}else if(stateII == 1){ 
191E:  BRA     198A
1920:  MOV     818,W4
1922:  CP      W4,#1
1924:  BRA     NZ,193C
.................... 				move_posZ(3000, 1);//To bag 
1926:  MOV     #BB8,W4
1928:  MOV     W4,846
192A:  MOV     #1,W4
192C:  MOV     W4,848
192E:  CALL    16E6
.................... 				//servo_Under(100); 
.................... 				delay_ms(1000); 
1932:  MOV     #3E8,W0
1934:  CALL    1812
.................... 				stateII++; 
1938:  INC     0818
.................... 				 
.................... 			}else if(stateII == 2){ 
193A:  BRA     198A
193C:  MOV     818,W4
193E:  CP      W4,#2
1940:  BRA     NZ,1974
.................... 				move_posZ(768, 0); //3390 
1942:  MOV     #300,W4
1944:  MOV     W4,846
1946:  CLR     848
1948:  CALL    16E6
.................... 				moveXYZ(goPosX, arrayData[3], goPosY, arrayData[4], 1536, 1);//Z is 20736 
194C:  MOV.B   809,W0L
194E:  MOV.B   W0L,W4L
1950:  SE      W4,W3
1952:  MOV     W3,82C
1954:  MOV.B   80A,W0L
1956:  MOV.B   W0L,6
1958:  SE      W3,W2
195A:  MOV     W2,830
195C:  PUSH    820
195E:  POP     82A
1960:  PUSH    822
1962:  POP     82E
1964:  MOV     #600,W2
1966:  MOV     W2,832
1968:  MOV     #1,W2
196A:  MOV     W2,834
196C:  CALL    17BE
.................... 				stateII++; 
1970:  INC     0818
.................... 			 
.................... 			}else if(stateII == 3){ 
1972:  BRA     198A
1974:  MOV     818,W4
1976:  CP      W4,#3
1978:  BRA     NZ,1984
.................... 				//servo_Under(250); 
.................... 				delay_ms(1000);  
197A:  MOV     #3E8,W0
197C:  CALL    1812
.................... 				stateII++; 
1980:  INC     0818
.................... 			}else{ 
1982:  BRA     198A
.................... 				set_Zero(); 
1984:  CALL    166A
.................... 				stateAll++; 
1988:  INC     081A
.................... 				} 
198A:  BRA     18E4
.................... 			} 
.................... 		}	 
198C:  BRA     18B0
.................... 	} 
.................... } 
....................  
198E:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9F7   NOPR NOALTI2C1 IOL1WAY NOOSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
